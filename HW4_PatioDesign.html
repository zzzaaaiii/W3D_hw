<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    #container {
        width: 60vw;
        height: 60vw;
        float: left;
        background-color: pink;
        margin: 10px;
    }

    p {
        margin: 10px;
        text-align: justify;
    }
</style>

<body>
    <h1 style="font-size:2em; text-align:center; margin:15px">
        Place, Delete
    </h1>

    <hr>

    <div id="container"></div>

    <div style="width:30vw; float:left; margin:10px;background-color:Plum">
        <input type=radio class='forni' id='tabling' name='c' value='table' checked> table <br> <br>
        <input type=radio class='forni' id='chairing' name='c' value='chair'> chair<br>
        <p id='debugMsg'>
        </p>
    </div>
    <button id='save'>Save</button>
    <button id='clear'>Clear</button>
    <button id='restore'>Restore</button>
    <div style="width:30vw;float:left; margin:10px;background-color:yellow">
        <input type=radio class='mode' id='placing' name='g' value='place' checked> Place <br>
        <input type=radio class='mode' id='deleting' name='g' value='delete'> Delete<br>
        <input type=radio class='mode' id='moving' name='g' value='move'> Move<br>
        </p>
    </div>

    <script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>



    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136/examples/jsm/controls/OrbitControls.js';
        import { MTLLoader } from 'https://cdn.skypack.dev/three@0.136/examples/jsm/loaders/MTLLoader.js';
        import { OBJLoader } from 'https://cdn.skypack.dev/three@0.136/examples/jsm/loaders/OBJLoader.js';
        $('.mode').click(function () {
            if ($(this).val() === 'place') { // place
                placing = true;
                deleting = false;
                moving = false;
            } else if ($(this).val() === 'delete') { // delete
                placing = false;
                deleting = true;
                moving = false;
            } else if ($(this).val() === 'move') { // move
                placing = false;
                deleting = false;
                moving = true;
            }

        });

        $('.forni').click(function () {
            if ($(this).val() === 'table') { // table
                pt = true;
                pc = false;
            } else if ($(this).val() === 'chair') { // chair
                pt = false;
                pc = true;
            }

        });

        var scene, renderer, camera;
        var plane;
        var puck;
        var mouse = new THREE.Vector2();
        var raycaster = new THREE.Raycaster();
        var placing = true, deleting = false, moving = false;
        var puckcs = [], puckts = [], thePuck, puckchair, pucktable;
        var controls, chair, table, chaircount = 0, tablecount = 0, pucks = [];
        var pt = true, pc = false, thePuckt, thePuckc, tn = 0;

        init();
        animate();

        function readChairModel(modelName, targetSize = 40) {
            var onProgress = function (xhr) {
                if (xhr.lengthComputable) {
                    var percentComplete = xhr.loaded / xhr.total * 100;
                    console.log(Math.round(percentComplete, 2) + '%downloaded');
                }
            };
            var onError = function (xhr) { };
            var mtlLoader = new MTLLoader();
            mtlLoader.setPath('model/');
            mtlLoader.load(modelName + '.mtl', function (materials) {
                materials.preload();

                var objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('model/');
                objLoader.load(modelName + '.obj', function (object) {

                    var c = unitize(object, targetSize);
                    c.name = 'OBJ';
                    c.position.y = 7.4;

                    chair = new THREE.Object3D();
                    chair.add(c);

                    //scene.add(car);

                }, onProgress, onError);

            });
        }

        function readTableModel(targetSize = 40) {
            var onProgress = function (xhr) {
                if (xhr.lengthComputable) {
                    var percentComplete = xhr.loaded / xhr.total * 100;
                    console.log(Math.round(percentComplete, 2) + '%downloaded');
                }
            };
            var onError = function (xhr) { };
            var mtlLoader = new MTLLoader();
            mtlLoader.setPath('model/');
            mtlLoader.load(modelName + '.mtl', function (materials) {
                materials.preload();

                var objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('model/');
                objLoader.load(modelName + '.obj', function (object) {

                    var c = unitize(object, targetSize);
                    c.name = 'OBJ';
                    c.position.y = 7.4;

                    table = new THREE.Object3D();
                    table.add(c);

                    //scene.add(car);

                }, onProgress, onError);

            });
        }

        $('#save').click(function () {

            var rects = [];
            if (puckts.length != 0) {
                for (let i = 0; i < puckts.length; i++) {
                    var rec = {};
                    rec.name = puckts[i].name;
                    rec.x = puckts[i].position.x.toFixed(2);
                    rec.z = puckts[i].position.z.toFixed(2);
                    rects.push(rec);
                }
            }
            var reccs = [];
            if (puckcs.length != 0) {
                for (let i = 0; i < puckcs.length; i++) {
                    var rec = {};
                    rec.name = puckcs[i].name;
                    rec.x = puckcs[i].position.x.toFixed(2);
                    rec.z = puckcs[i].position.z.toFixed(2);
                    reccs.push(rec);
                }
            }
            // puckRecs --> JSON.stringify --> localStorage
            var recLogt = JSON.stringify(rects);
            var recLogc = JSON.stringify(reccs);
            localStorage.setItem('puckLogt', recLogt);
            localStorage.setItem('puckLogc', recLogc);

        });

        $('#clear').click(function () {

            puckcs.forEach(function (puckchair) {
                puckchair.removeFromParent();
            })

            puckts.forEach(function (pucktable) {
                pucktable.removeFromParent();
            })

            puckts = [];
            puckcs = [];
        });

        $('#restore').click(function () {

            var parseLogt = JSON.parse(localStorage.getItem('puckLogt'));
            if (parseLogt != null) {
                for (let i = 0; i < parseLogt.length; i++) {
                    var newPuck = pucktable.clone();
                    newPuck.position.set(parseLogt[i].x, 20, parseLogt[i].z);
                    scene.add(newPuck);
                    puckts.push(newPuck);
                }
            }
            var parseLogc = JSON.parse(localStorage.getItem('puckLogc'));
            if (parseLogc != null) {
                for (let i = 0; i < parseLogc.length; i++) {
                    var newPuck = puckchair.clone();
                    newPuck.position.set(parseLogc[i].x, 10, parseLogc[i].z);
                    scene.add(newPuck);
                    puckcs.push(newPuck);
                }
            }
        });

        function init() {

            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            var ww = $('#container').innerWidth();
            var hh = $('#container').innerHeight();
            renderer.setSize(ww, hh);
            renderer.setClearColor(0x555555);
            $('#container').append(renderer.domElement);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(45, ww / hh, 1, 10000);
            camera.position.set(0, 80, 200);
            camera.lookAt(new THREE.Vector3(0, 0, 0));


            var cyl_geom = new THREE.CylinderGeometry(10, 10, 6, 32);
            var cyl_mat = new THREE.MeshNormalMaterial();
            puck = new THREE.Mesh(cyl_geom, cyl_mat);

            controls = new OrbitControls(camera, renderer.domElement);

            var gridXZ = new THREE.GridHelper(200, 20, 'red', 'white');
            scene.add(gridXZ);

            // build an invisible plane, overlapping the grid
            plane = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200, 8, 8),
                new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    opacity: 0.25,
                    transparent: true
                }));
            plane.rotation.x = -Math.PI / 2;
            plane.material.visible = true; // invisible, for picking only
            scene.add(plane);

            window.addEventListener('resize', onWindowResize, false);
            $('#container').on("pointerdown", onMouseDown);
            $('#container').on("pointermove", onMouseMove);
            $('#container').on("pointerup", onMouseUp);

            thePuck = null;
        }

        function onWindowResize() {
            var ww = $('#container').innerWidth();
            var hh = $('#container').innerHeight();
            camera.aspect = ww / hh;
            camera.updateProjectionMatrix();
            renderer.setSize(ww, hh);
        }

        function buildChair() {
            readChairModel('chair');
            //chair = new THREE.Object3D();
            chair.position.y = 10;
            return chair;
        }

        function buildTable() {
            var cyl_geom = new THREE.CylinderGeometry(10, 10, 60, 32);
            var cyl_mat = new THREE.MeshNormalMaterial();
            table = new THREE.Mesh(cyl_geom, cyl_mat);
            return table;
        }

        function onMouseDown(event) {

            var viewportPos = $('#container').get(0).getBoundingClientRect();
            mouse.x = ((event.clientX - viewportPos.left) / $('#container').innerWidth()) * 2 - 1;
            mouse.y = -((event.clientY - viewportPos.top) / $('#container').innerHeight()) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            if (pc === true) {
                puckchair = buildChair();
                chaircount++;
            } else if (pt === true) {
                pucktable = buildTable();
                tablecount++;
            }

            if (placing === true) { // place
                var intersects = raycaster.intersectObject(plane);
                if (intersects.length > 0) {
                    if (pt === true && tn === 0) {
                        var newPuck = pucktable.clone(); //makePuck();
                        newPuck.position.copy(intersects[0].point);
                        newPuck.position.y = 20;
                        scene.add(newPuck);
                        puckts.push(newPuck);
                        pucks.push(newPuck);
                        tn++;
                    } else if (pc === true) {
                        var newPuck = puckchair; //makePuck();
                        newPuck.position.copy(intersects[0].point);
                        newPuck.position.y = 10;
                        scene.add(newPuck);
                        puckcs.push(newPuck);
                        pucks.push(newPuck);
                    }
                }
            } else if (deleting === true) {
                var intersectst = raycaster.intersectObjects(puckts); //table
                var intersectsc = raycaster.intersectObjects(puckcs); //chair
                console.log(intersectst);
                console.log(intersectsc);
                if (pt === true) {
                    thePuckt = intersectst[0].object;
                    thePuckt.removeFromParent();

                    // remove thePuck from puckts
                    for (let i = 0; i < puckts.length; i++) {
                        if (puckts[i] === thePuckt) {
                            puckts.splice(i, 1);
                        }
                        if (pucks[i] === thePuckt) {
                            pucks.splice(i, 1);
                            break;
                        }
                    }
                    tn--;
                }
                if (pc === true) {
                    thePuckc = intersectsc[0].object;
                    thePuckc.removeFromParent();

                    // remove thePuck from puckcs
                    for (let i = 0; i < puckcs.length; i++) {
                        if (puckcs[i] === thePuckc) {
                            puckcs.splice(i, 1);
                        }
                        if (pucks[i] === thePuckc) {
                            pucks.splice(i, 1);
                            break;
                        }
                    }
                }

            } else if (moving === true) {
                var intersects = raycaster.intersectObjects(pucks);
                if (intersects.length > 0) {
                    thePuck = intersects[0].object;
                }
            }
        }

        function onMouseUp(event) {

            thePuckc = null;
            thePuckt = null
            if (moving === true) {
                thePuck = null;
                controls.enabled = true;
            }

            if (puckcs.length === 0 && puckts === 0) {
                placing = true;
                deleting = false;
                moving = false;
                $('#placing').prop('checked', true);
                // https://stackoverflow.com/questions/15044340/jquery-set-checkbox-checked
            }

        }

        function onMouseMove(event) {
            event.preventDefault();
            if (thePuck === null) return;

            var viewportPos = $('#container').get(0).getBoundingClientRect();
            mouse.x = ((event.clientX - viewportPos.left) / $('#container').innerWidth()) * 2 - 1;
            mouse.y = -((event.clientY - viewportPos.top) / $('#container').innerHeight()) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObject(plane);
            if (intersects.length > 0) {
                controls.enabled = false; // to disable camera movement

                thePuck.position.copy(intersects[0].point);
            }

        }

        function animate() {

            requestAnimationFrame(animate);
            render();

        }

        function render() {
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>